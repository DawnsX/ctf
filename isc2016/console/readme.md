这题三个func，第一个啥也没做，第二个应该是可以泄露各种地址，第三个溢出

用曾师傅脚本里  e=ELF("/lib32/libc.so.6")  的时候出错了，因为我根本没这个文件夹，也没在/lib下找到类似文件
他说你ldd一下，果然找到了 = =。这个命令“ 用于判断某个可执行的 binary 档案含有什么动态函式库”
然而还是不行= =我特么。。。查了下似乎是因为kali版本太新，网上又到处找不到旧版的vm image
后来找曾sf拷了个虚拟机才ok，同时觉得32位kali加64位ubuntu的组合不错

另外原来checksec和pattern在peda上都有，惊讶


开始写脚本
首先，用s1去覆盖buf指向的内容并不难，难的是如何让s1和s2相等。。长度16的和20的咋相等咯，能输入\x00吗
让我来试一哈，主要是\x00之后的内容能read进去吗？在804875B下断。。
虽然peda自动显示的碰到\x00后面的都不显示。。 但，结论是可以的！那就简单了~

另外还碰到了一个坑，就是read的时候，回车也是算一个字符的
所以那个strlen要求为16的token，用p.sendline('a'*15)和p.sendline("a"*16+'\x00')都能过
而后面那个要覆盖地址的是p.send('\x00'+'x'*15+p32(readgot))，sendline就报错~
（讲真这个要是没看wr咋办T T 

p32和u32之前容易弄混，分别是 数字->字符串 和 字符串->数字，packing和unpacking的意思
还有log.success("xxx")，跟输出没两样嘛= =

之后看不懂exp里为啥用了strncmp的地址，曾sf说因为它是最后一个函数，不怕覆盖它毁后面

最后就是不理解那个strncmpgot+4+0x1c的4+0x1c哪来的= =
是因为走到strncmp（被覆盖之后就是system）的时候，参数跟ebp-0x1c有关。。所以啊，是调参数用的
